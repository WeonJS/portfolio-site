<!DOCTYPE html>
<html>
    <link rel="stylesheet" type="text/css" href="style.css" />
    <head>
        <title>Keon Davoudi</title>
        <script src="https://unpkg.com/vue@next"></script>
    </head>

    <body>

        <div id="app">

            <div id="welcomeText">
                <h1>I'm <strong class="lavender">Keon</strong>,</h1>
                <h3>computer science student at asu</h3>
            </div>
        </div>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" integrity="sha512-dLxUelApnYxpLt6K2iomGngnHO83iUvZytA3YjDUCjT0HDOHKXnVYdf3hU4JjM8uEhxf9nD1/ey98U3t2vZ0qQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="vector.js"></script>
        <script>

            var planets = [];
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
            const G = 0.000000067;

            class Planet {
                constructor(mass) { // color as hex
                    this.mass = mass;
                    this.force = new Vector(0, 0, 0);
                    this.vel = new Vector(0, 0, 0);
                    this.pos = new Vector(0, 0, 0);
                    this.r = 0;
                    

                    this.geometry = new THREE.SphereGeometry( this.mass, 32, 6 );
                    this.material = new THREE.MeshLambertMaterial( {color: 0xffffff} );
                    this.sphere = new THREE.Mesh( this.geometry, this.material );
                    camera.position.z = 10;
                    this.sphere.position.x = Math.random() * 10 - Math.random() * 10;
                    this.sphere.position.y = Math.random() * 5 - Math.random() * 5;
                    scene.add( this.sphere );
                    planets.push(this);
                }

                update(sphr) {
                    this.pos = new Vector(this.sphere.position.x, this.sphere.position.y, this.sphere.position.z);
                    for (const p in planets) {
                        var r = Math.sqrt(Math.pow(planets[p].sphere.position.x - this.sphere.position.x, 2) + Math.pow(planets[p].sphere.position.y - this.sphere.position.y, 2));
                        //console.log(mag);
                        var dir = planets[p].pos.subtract(this.pos).divide(r);
                        var m1 = this.mass;
                        var m2 = planets[p].mass;
                        var f = G * (m1 * m2) / Math.pow(r, 2);
                        //console.log(r);

                        this.force = this.force.add(dir.multiply(f));
                        //console.log(this.force);
                    }
                    sphr.rotation.z += 0.01;
                    //console.log(this.force);
                    this.vel = this.vel.add(this.force);

                    // limit velocity
                    var maxVel = 0.01;
                    if (this.vel.x > maxVel) {
                        this.vel.x = maxVel;
                    } else if (this.vel.x < -maxVel) {
                        this.vel.x = -maxVel;
                    }

                    if (this.vel.y > maxVel) {
                        this.vel.y = maxVel;
                    } else if (this.vel.y < -maxVel) {
                        this.vel.y = -maxVel;
                    }
                    
                    this.sphere.position.x += this.vel.x + (Math.random() - Math.random()) /  70;
                    this.sphere.position.y += this.vel.y + (Math.random() - Math.random()) / 70;

                    // spheres wont leave bounds
                    var xbound = 15;
                    var ybound = 10;
                    if (this.sphere.position.x > xbound) {
                        this.sphere.position.x = -xbound;
                    } else if (this.sphere.position.x < -xbound) {
                        this.sphere.position.x = xbound;
                    }

                    if (this.sphere.position.y > ybound) {
                        this.sphere.position.y = -ybound;
                    } else if (this.sphere.position.y < -ybound) {
                        this.sphere.position.y = ybound;
                    }
                    

                    // if (this.sphere.position.x > xbound) {
                    //     this.vel.x *= -1;
                    // } else if (this.sphere.position.x < -xbound) {
                    //     this.vel.x *= -1;
                    // }

                    // if (this.sphere.position.y > ybound) {
                    //     this.vel.y *= -1;
                    // } else if (this.sphere.position.y < -ybound) {
                    //     this.vel.y *= -1;
                    // }
                }
            }

            for (var i = 0; i < 10; i++) {
                new Planet(Math.random()+0.2);
            }
            
            const renderer = new THREE.WebGLRenderer({alpha: true});
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            
            renderer.setClearColor( 0xffffff, 1 );

            

            const light = new THREE.PointLight( 0xffffff, 10, 100 );
            light.position.set( 50, 50, 50 );
            scene.add( light );
            

            function animate() {
                requestAnimationFrame( animate );
                renderer.render( scene, camera );
                planets.forEach(element => {
                    element.update(element.sphere);
                });
            }
            animate();
        </script>

        <script src="app.js"></script>
    </body>
</html>